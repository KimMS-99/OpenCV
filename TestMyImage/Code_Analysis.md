# C++ 이미지 처리 코드 분석

이 문서는 `MyImage.h`, `TestMyImage.cpp`, `bmpheader.h` 세 파일로 구성된 C++ 이미지 처리 프로젝트를 분석하고 설명합니다. 이 코드는 외부 라이브러리(OpenCV 등) 없이 순수 C++만으로 이미지 데이터를 다루고 BMP 파일로 저장하는 방법을 보여주는 훌륭한 예제입니다.

---

## 1. `MyImage.h` - 이미지 클래스 상세 분석

이 파일은 이미지 데이터를 캡슐화하고 조작하는 핵심 클래스인 `CMyImage`를 정의합니다. 템플릿으로 작성되어 `BYTE`, `int`, `float` 등 다양한 데이터 타입의 이미지를 처리할 수 있습니다.

### 1.1. 클래스 구조
```cpp
template <typename T>
class CMyImage
{
public:
    // 생성자, 소멸자, 연산자 등
    // 멤버 함수 (Load/Save, Get/Set 등)

protected:
    int m_nChannels;    // 채널 수
    int m_nHeight;      // 세로 픽셀 수
    int m_nWidth;       // 가로 픽셀 수
    int m_nWStep;       // 행당 데이터 원소 수 (패딩 포함)
    T* m_pImageData;    // 픽셀 배열 포인터
};

// Typedefs for common image types
typedef CMyImage <BYTE> CByteImage;
typedef CMyImage <int> CIntImage;
// ...
```

### 1.2. 주요 멤버 변수

- `m_nWidth`, `m_nHeight`: 이미지의 가로, 세로 크기를 픽셀 단위로 저장합니다.
- `m_nChannels`: 이미지의 채널 수를 나타냅니다. (1: 그레이스케일, 3: BGR 컬러)
- `m_pImageData`: 실제 픽셀 데이터가 저장되는 동적 할당된 메모리 공간을 가리키는 포인터입니다.
- `m_nWStep`: **(중요)** 이미지 한 행(row)을 저장하는 데 필요한 **데이터 요소(element)의 개수**입니다. 단순한 가로 길이가 아니라 메모리 정렬(패딩)이 적용된 값입니다.

### 1.3. `m_nWStep` 계산 심층 분석

`m_nWStep`은 다음 코드로 계산되며, 이는 이미지 처리에서 매우 중요한 개념입니다.

```cpp
m_nWStep = ((m_nWidth * m_nChannels * sizeof(T) + 3) & ~3) / sizeof(T);
```

이 코드의 목적은 **이미지 한 행의 메모리 크기를 4바이트의 배수로 맞추는 것**입니다.

**왜 필요한가?**
1.  **BMP 파일 형식:** BMP 표준은 각 행의 데이터 크기가 4바이트 배수여야 한다고 규정합니다. 부족한 공간은 의미 없는 값(패딩)으로 채워야 합니다.
2.  **CPU 처리 효율:** 대부분의 CPU는 메모리 주소가 4의 배수일 때 데이터를 가장 효율적으로 읽고 쓸 수 있습니다.

**계산 과정:**

1.  `m_nWidth * m_nChannels * sizeof(T)`
    - 한 행의 **순수 데이터 크기**를 바이트 단위로 계산합니다.
    - 예: 640x480 1채널 `BYTE` 이미지의 경우 `640 * 1 * 1 = 640` 바이트.

2.  `... + 3`
    - 4의 배수로 "올림"하기 위한 준비 단계입니다.
    - 예: `640 + 3 = 643`.

3.  `... & ~3`
    - **4의 배수로 맞추는 핵심 비트 연산입니다.**
    - `~3`은 이진수로 `...11111100` 입니다. 이 마스크와 AND(`&`) 연산을 하면 마지막 두 비트가 강제로 0이 되어, 결과값은 항상 4의 배수가 됩니다.
    - 예: `643` (이진수 `1010000011`) & `...11111100` = `1010000000` (십진수 `640`).
    - 만약 순수 데이터 크기가 639였다면, `(639 + 3) & ~3` => `642 & ~3` => `640`이 됩니다. (올림이 아닌 내림으로 동작하는 것처럼 보이지만, 이는 정수 나눗셈의 버림 효과와 유사하게 동작하여 올바른 배수 값을 찾습니다. 정확히는 '가장 가까운 작은 4의 배수'를 찾는 연산입니다. `+3`을 통해 올림 효과를 내는 것입니다.)

4.  `... / sizeof(T)`
    - 위에서 계산된 **총 바이트 크기**를 다시 데이터 타입 `T`의 크기로 나눕니다.
    - `m_nWStep`은 바이트 수가 아닌 `T` 타입 요소의 개수를 저장하기 때문입니다.
    - 예: `640` 바이트 / `sizeof(BYTE)` (1) = `640`. `m_nWStep`은 640이 됩니다.

### 1.4. 주요 멤버 함수 분석

- **생성자 및 소멸자**
  - `CMyImage(int nWidth, int nHeight, ...)`: 너비, 높이, 채널 수를 받아 `m_nWStep`을 계산하고, `m_nHeight * m_nWStep` 만큼의 메모리를 동적으로 할당합니다.
  - `CMyImage(const CMyImage& myImage)` (복사 생성자): 다른 이미지 객체를 깊은 복사(deep copy)합니다. 즉, 픽셀 데이터를 담을 새로운 메모리를 할당하고 내용을 그대로 복사해옵니다.
  - `~CMyImage()`: 객체가 소멸될 때 `m_pImageData`가 가리키는 메모리를 `delete[]`로 해제하여 메모리 누수를 방지합니다.

- **`operator=` (대입 연산자)**
  - `imageA = imageB;` 와 같은 연산을 처리합니다. 자기 자신에게 대입하는 경우를 방지하고, 기존 데이터를 해제한 뒤 새로운 데이터를 깊은 복사합니다.

- **`LoadImage(const char* filename)` / `SaveImage(const char* filename)`**
  - BMP 파일을 읽고 쓰는 함수입니다. `bmpheader.h`에 정의된 구조체를 사용하여 파일 헤더와 정보 헤더를 읽거나 씁니다.
  - `SaveImage`에서는 1채널(그레이스케일) 이미지일 경우, 256색상 팔레트 정보를 추가로 기록합니다.
  - BMP 파일은 상하가 뒤집혀 저장되므로, for문을 `r = m_nHeight - 1` 부터 `0`까지 역순으로 돌면서 데이터를 읽고 씁니다.

- **`GetAt(int x, int y, int c = 0)`**
  - `(x, y)` 좌표의 특정 채널(`c`)에 있는 픽셀 데이터의 참조(`&`)를 반환합니다.
  - `m_pImageData[m_nWStep * y + m_nChannels * x + c]` 수식을 통해 1차원 배열로 저장된 픽셀 데이터에서 원하는 위치를 정확히 찾아냅니다. `m_nWStep`을 사용함으로써 패딩을 올바르게 건너뛸 수 있습니다.

---

## 2. `TestMyImage.cpp` - 이미지 생성 및 조작

이 파일은 `CMyImage` 클래스를 실제로 사용하여 이미지를 만들고 조작하는 방법을 보여주는 실행 코드입니다.

### 2.1. 주요 흐름

1.  **이미지 객체 생성**: `CByteImage image1(640, 480);` 코드로 640x480 크기의 1채널 `BYTE` 이미지 객체를 생성합니다. 복사 생성자, 대입 연산자 호출 예제도 포함되어 있습니다.
2.  **이미지 초기화 및 생성**:
    - `image1` (`Black.bmp`): `SetConstValue(0)`으로 모든 픽셀을 0(검은색)으로 채웁니다.
    - `image2` (`GradationX.bmp`): 이중 for문을 돌며 x좌표(`c`)가 증가할수록 값이 밝아지는 가로 그라데이션을 만듭니다.
    - `image3` (`GradationY.bmp`): y좌표(`r`)가 증가할수록 값이 밝아지는 세로 그라데이션을 만듭니다.
3.  **이미지 연산**:
    - `image4` (`GradationXY.bmp`): `image2`와 `image3`의 픽셀 값을 절반씩 더해 대각선 그라데이션을 만듭니다.
    - `image5` (`GradationYX.bmp`): `image4`의 픽셀 값을 비트 NOT 연산자(`~`)를 사용해 색상을 반전시킵니다.
4.  **파일 저장**: `SaveImage()` 함수를 호출하여 메모리에서 작업한 결과물들을 실제 BMP 파일로 디스크에 저장합니다.

---

## 3. `bmpheader.h` - BMP 파일 구조 정의

이 파일은 BMP 파일의 표준 데이터 구조를 C언어 구조체로 정의합니다. `LoadImage`/`SaveImage` 함수가 이 구조체들을 이용해 파일 데이터를 해석하고 생성합니다.

- **`BITMAPFILEHEADER`**: 파일의 맨 앞에 오는 정보. 파일이 BMP임을 알리는 `bfType` ('BM'), 전체 파일 크기 `bfSize` 등을 포함합니다.
- **`BITMAPINFOHEADER`**: 이미지의 실질적인 정보. 너비(`biWidth`), 높이(`biHeight`), 픽셀당 비트 수(`biBitCount`) 등을 포함합니다.
- **`RGBQUAD`**: 8비트 이하의 이미지에서 사용되는 색상 팔레트(Color Table)의 각 항목을 정의합니다.
- **`__attribute__((__packed__))`**: 구조체 멤버 사이에 컴파일러가 임의로 바이트를 추가하는 "패딩"을 막는 지시어입니다. 이를 통해 구조체의 메모리 레이아웃이 파일에 저장된 형식과 정확히 일치하게 됩니다.

---

## 4. OpenCV와의 관계

이 코드는 **OpenCV와 전혀 관련이 없습니다.** OpenCV는 고도로 최적화된 이미지/영상 처리 라이브러리로, `cv::Mat`이라는 강력한 클래스를 제공하며 파일 입출력, 이미지 연산 등을 매우 간결한 코드로 수행할 수 있게 해줍니다.

반면, 이 프로젝트는 그러한 라이브러리 없이 이미지 데이터가 메모리에서 어떻게 표현되고, BMP 파일 형식이 어떻게 구성되는지와 같은 **근본적인 원리를 학습할 목적**으로 작성된 코드입니다.
